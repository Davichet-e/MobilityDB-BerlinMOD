<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Chapter 3. BerlinMOD Benchmark on MobilityDB</title><link rel="stylesheet" type="text/css" href="docbook.css"><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot"><link rel="home" href="index.html" title="BerlinMOD Benchmark on MobilityDB"><link rel="up" href="index.html" title="BerlinMOD Benchmark on MobilityDB"><link rel="prev" href="ch02s11.html" title="Creating a Graph from Input Data"><link rel="next" href="ch03s02.html" title="Loading the Data in Partitioned Tables"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 3. BerlinMOD Benchmark on MobilityDB</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch02s11.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ch03s02.html">Next</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="benchmark"></a>Chapter 3. BerlinMOD Benchmark on MobilityDB</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="sect1"><a href="ch03.html#idm964">Loading the Data</a></span></dt><dt><span class="sect1"><a href="ch03s02.html">Loading the Data in Partitioned Tables</a></span></dt><dt><span class="sect1"><a href="ch03s03.html">BerlinMOD/R Queries</a></span></dt></dl></div><p><a class="ulink" href="http://dna.fernuni-hagen.de/secondo/BerlinMOD/BerlinMOD.html" target="_top">BerlinMOD</a> is a standard benchmark for moving object DBMSs. It provides a data generator, pregenerated benchmark data for different scale factors, and set of queries of two types: 17 range-style queries (called BerlinMOD/R), and 9 nearest-neighbours queries (called BerlinMOD/NN). The MobilityDB tutorial presented in <a class="xref" href="ch01.html" title="Chapter 1. MobilityDB Tutorial">Chapter 1, <i>MobilityDB Tutorial</i></a> and its associated data were based on BerlinMOD. However, its purpose was to show the capabilities of MobilityDB. In this chapter, we show how to load pregenerated BerlinMOD data on MobilityDB and how to express the 17 queries in BerlinMOD/R. Some of these queries were already presented in <a class="xref" href="ch01.html" title="Chapter 1. MobilityDB Tutorial">Chapter 1, <i>MobilityDB Tutorial</i></a>.</p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idm964"></a>Loading the Data</h2></div></div></div><p>
		The script for loading pregenerated data is available <a class="ulink" href="https://docs.mobilitydb.com/data/berlinmod_load.sql" target="_top">here</a>.
			</p><pre class="programlisting">
-------------------------------------------------------------------------------
-- Loads the BerlinMOD data in projected (2D) coordinates with SRID 5676
-- https://epsg.io/5676
-------------------------------------------------------------------------------

DROP FUNCTION IF EXISTS berlinmod_load();
CREATE OR REPLACE FUNCTION berlinmod_load(scale_factor text DEFAULT '0.005',
  path text DEFAULT '/usr/local/BerlinMOD/') 
RETURNS text AS $$
DECLARE
  fullpath text;
BEGIN
  fullpath = path || scale_factor || '/';
  DROP TABLE IF EXISTS streets;
  CREATE TABLE streets (
    StreetId integer,
    vmax integer,
    x1 double precision,
    y1 double precision,
    x2 double precision,
    y2 double precision,
    Geom geometry(LineString, 5676) );
  EXECUTE format('COPY streets(StreetId, vmax, x1, y1, x2, y2) FROM ''%sstreets.csv'' 
    DELIMITER '','' CSV HEADER', fullpath);
  UPDATE streets
  SET Geom = ST_Transform(ST_SetSRID(ST_MakeLine(ARRAY[ST_MakePoint(x1, y1),
    ST_MakePoint(x2, y2)]), 4326), 5676);

  DROP TABLE IF EXISTS Points CASCADE;
  CREATE TABLE Points (
    PointId integer,
    PosX double precision,
    PosY double precision,
    Geom geometry(Point, 5676) );
  EXECUTE format('COPY Points(PointId, PosX, PosY) FROM ''%spoints.csv'' 
    DELIMITER  '','' CSV HEADER', fullpath);
  UPDATE Points
  SET Geom = ST_Transform(ST_SetSRID(ST_MakePoint(PosX, PosY), 4326), 5676);

  CREATE INDEX Points_geom_idx ON Points USING gist(Geom);

  CREATE VIEW Points1(PointId, PosX, PosY, Geom) AS
  SELECT PointId, PosX, PosY, Geom
  FROM Points
  LIMIT 10;

  DROP TABLE IF EXISTS RegionsInput CASCADE;
  CREATE TABLE RegionsInput (
    RegionId integer,
    SegNo integer,
    XStart double precision,
    YStart double precision,
    XEnd double precision,
    YEnd double precision );
  EXECUTE format('COPY RegionsInput(RegionId, SegNo, XStart, YStart, XEnd, YEnd) 
    FROM ''%sregions.csv'' DELIMITER  '','' CSV HEADER', fullpath);

  DROP TABLE IF EXISTS Regions CASCADE;
  CREATE TABLE Regions (
    RegionId integer,
    Geom Geometry(Polygon, 5676) );
  INSERT INTO Regions (RegionId, Geom)
  WITH RegionsSegs AS (
    SELECT RegionId, SegNo, ST_Transform(ST_SetSRID(St_MakeLine(
      ST_MakePoint(XStart, YStart), ST_MakePoint(XEnd, YEnd)), 4326), 5676) AS Geom
    FROM RegionsInput )
  SELECT RegionId, ST_Polygon(ST_LineMerge(ST_Union(Geom ORDER BY SegNo)), 5676) AS Geom
  FROM RegionsSegs
  GROUP BY RegionId;

  CREATE INDEX Regions_geom_idx ON Regions USING gist(Geom);

  CREATE VIEW Regions1(RegionId, Geom) AS
  SELECT RegionId, Geom
  FROM Regions
  LIMIT 10;

  DROP TABLE IF EXISTS Instants CASCADE;
  CREATE TABLE Instants (
    InstantId integer,
    Instant timestamptz );
  EXECUTE format('COPY Instants(InstantId, Instant) FROM ''%sinstants.csv''
    DELIMITER  '','' CSV HEADER', fullpath);

  CREATE INDEX Instants_instant_btree_idx ON Instants USING btree(instant);

  CREATE VIEW Instants1(InstantId, Instant) AS
  SELECT InstantId, Instant 
  FROM Instants
  LIMIT 10;

  DROP TABLE IF EXISTS Periods CASCADE;
  CREATE TABLE Periods (
    PeriodId integer,
    BeginP timestamp,
    EndP timestamp,
    Period tstzspan );
  EXECUTE format('COPY Periods(PeriodId, BeginP, EndP) FROM ''%speriods.csv'' 
    DELIMITER  '','' CSV HEADER', fullpath);
  UPDATE Periods
  SET Period = tstzspan(BeginP,EndP);

  CREATE INDEX Periods_Period_gist_idx ON Periods USING gist(Period);

  CREATE VIEW Periods1(PeriodId, BeginP, EndP, Period) AS
  SELECT PeriodId, BeginP, EndP, Period
  FROM Periods
  LIMIT 10;

  DROP TABLE IF EXISTS Vehicles CASCADE;
  CREATE TABLE Vehicles (
    VehId integer PRIMARY KEY,
    Licence varchar(32),
    Type varchar(32),
    Model varchar(32) );
  EXECUTE format('COPY Vehicles(VehId, Licence, Type, Model) FROM ''%svehicles.csv'' 
    DELIMITER  '','' CSV HEADER', fullpath);

  DROP TABLE IF EXISTS Licences CASCADE;
  CREATE TABLE Licences (
    VehId integer PRIMARY KEY,
    LicenceId integer,
    Licence varchar(8) );
  EXECUTE format('COPY Licences(Licence, LicenceId) FROM ''%slicences.csv'' 
    DELIMITER  '','' CSV HEADER', fullpath);
  UPDATE Licences Q
  SET VehId = ( SELECT C.VehId FROM Vehicles C WHERE C.Licence = Q.Licence );

  CREATE INDEX Licences_VehId_idx ON Licences USING btree(VehId);

  CREATE VIEW Licences1(LicenceId, Licence, VehId) AS
  SELECT LicenceId, Licence, VehId
  FROM Licences
  LIMIT 10;

  CREATE VIEW Licences2(LicenceId, Licence, VehId) AS
  SELECT LicenceId, Licence, VehId
  FROM Licences
  LIMIT 10 OFFSET 10;

  DROP TABLE IF EXISTS TripsInput CASCADE;
  CREATE TABLE TripsInput (
    VehId integer,
    TripId integer,
    TStart timestamp without time zone,
    TEnd timestamp without time zone,
    XStart double precision,
    YStart double precision,
    XEnd double precision,
    YEnd double precision,
    Geom geometry(LineString) );
  EXECUTE format('COPY TripsInput(VehId, TripId, TStart, TEnd, XStart, YStart, XEnd, YEnd) 
    FROM ''%strips.csv'' DELIMITER  '','' CSV HEADER', fullpath);
  UPDATE TripsInput
  SET Geom = ST_Transform(ST_SetSRID(ST_MakeLine(ARRAY[ST_MakePoint(XStart, YStart),
    ST_MakePoint(XEnd, YEnd)]), 4326), 5676);

  DROP TABLE IF EXISTS TripsInputInstants;
  CREATE TABLE TripsInputInstants AS (
  SELECT VehId, TripId, TStart, XStart, YStart, 
    ST_Transform(ST_SetSRID(ST_MakePoint(XStart, YStart), 4326), 5676) as Geom
  FROM TripsInput
  UNION ALL
  SELECT T1.VehId, T1.TripId, T1.TEnd, T1.XEnd, T1.YEnd, 
    ST_Transform(ST_SetSRID(ST_MakePoint(T1.XEnd, T1.YEnd), 4326), 5676) as Geom
  FROM TripsInput T1 INNER JOIN (
    SELECT VehId, TripId, max(TEnd) as MaxTend
    FROM TripsInput 
    GROUP BY VehId, TripId
  ) T2 ON T1.VehId = T2.VehId AND T1.TripId = T2.TripId AND T1.TEnd = T2.MaxTend );
  ALTER TABLE TripsInputInstants ADD COLUMN inst tgeompoint;
  UPDATE TripsInputInstants
  SET inst = tgeompoint_inst(Geom, TStart);

  DROP TABLE IF EXISTS Trips CASCADE;
  CREATE TABLE Trips (
    TripId integer PRIMARY KEY,
    VehId integer NOT NULL,
    Trip tgeompoint,
    Traj geometry,
    PRIMARY KEY (VehId, TripId),
    FOREIGN KEY (VehId) REFERENCES Vehicles(VehId));
  INSERT INTO Trips
  SELECT VehId, TripId, tgeompoint_seq(array_agg(inst ORDER BY TStart))
  FROM TripsInputInstants
  GROUP BY VehId, TripId;
  UPDATE Trips
  SET Traj = trajectory(Trip);

  CREATE INDEX Trips_VehId_idx ON Trips USING btree(VehId);
  CREATE INDEX Trips_gist_idx ON Trips USING gist(trip);

  DROP VIEW IF EXISTS Trips1;
  CREATE VIEW Trips1 AS
  SELECT * FROM Trips LIMIT 100;

  -- Drop temporary tables
  DROP TABLE RegionsInput;
  DROP TABLE TripsInput;
  DROP TABLE TripsInputInstants;

  RETURN 'The End';
END;
$$ LANGUAGE 'plpgsql';
			</pre><p>
			The script above creates a procedure to load pregenerated BerlinMOD data (in CSV format and WGS84 coordinates) at various scale factors. The procedure has two parameters: the scale factor and the directory where the CSV files are located. It supposes by default that the scale factor is <code class="varname">0.005</code> and that the CSV files are located in the directory <code class="varname">/usr/local/BerlinMOD/&lt;scale factor&gt;/</code>. Notice that the procedure creates GiST indexes for the tables. Alternatively, SP-GiST indexes could be used. The procedure can be called, for example, as follows.
			</p><pre class="programlisting">
SELECT berlinmod_load('0.05');
			</pre><p>
		</p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch02s11.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="ch03s02.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Creating a Graph from Input Data </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Loading the Data in Partitioned Tables</td></tr></table></div></body></html>
